Buonasera Professore,

Le allego il PDF con l'aggiunta di: 
- una breve esposizione degli obiettivi, dal momento che Lei ne aveva evidenziato la mancanza: si tratta di fornire un’analisi critica delle soluzioni di design proposte, fornendo valutazioni di performance e di sicurezza in base a test effettuati su applicazioni di esempio, con deploy su AWS.
- aggiunta di un paragrafo al primo capitolo su cloud computing, infrastructure as code e continuous integration, che erano gli argomenti di tirocinio.
- secondo capitolo (Descrizione delle tecnologie). Ho mostrato le API ed il funzionamento interno delle librerie Nuxt e TypeORM, facendo degli esempi di casi d'uso tipici, aggiungendo diagrammi di sequenza, uml ed entity-relationship e snippet di codice.

Nel frattempo ho preparato una repository (https://github.com/iacobucci/aws-nuxt-typeorm), dove ho testato il branch principale per l'infrastructure as code e la continuous integration con AWS e Github Actions, continuando l'argomento di tirocinio, e rilasciando un'applicazione di test che usa Nuxt e TypeORM in combinazione. Alla pagina https://github.com/iacobucci/aws-nuxt-typeorm/actions si può vedere come i workflow di creazione e poi anche di aggiornamento siano stati eseguito con successo, su un nuovo account AWS con free-tier. Nel branch di sviluppo della repository, https://github.com/iacobucci/aws-nuxt-typeorm/tree/dev, Ho aggiunto anche dei componenti per il frontend personalizzati, insieme a test unitari automatizzati, sia di feature di Nuxt che di query TypeORM.

Ho pensato che i test di stress, load e performance dell'app da includere nel capitolo 3 di cui Lei mi parlava si potrebbero declinare in un modo simile a questo:

- Per AWS: Testare la velocità di risposta del server in relazione al numero di richieste HTTP anche in base alla topologia della rete (server sotto forma di container orchestrati con database in cloud per un'applicazione SSR, funzioni serverless con database in cloud per un'applicazione SSG).
- Per Nuxt: Testare la velocità di rendering di pagine in alcuni scenari tipici che vedono componenti innestati, in funzione della modalità di rendering scelta (CSR, SSG, SSR, UR), con gli strumenti sviluppatore di un browser web, come "lighthouse" per Chromium o il profiler di Firefox: vengono forniti degli score di performance, accessibilità, best practices e search engine optimization che si possono usare come metrica comparativa.
- Per TypeORM: Testare la velocità delle query mostrate negli esempi del capitolo 2, tra pattern Active Record, Query Builder e SQL raw.

Per la continuazione nel capitolo 3 (Soluzioni di design), avevo pensato alle seguenti sezioni:
- Spiegazione della IaC e CI/CD con AWS e Github Actions, da argomento di tirocinio, applicata al contesto delle tecnologie in esame e con snippet di codice, che permettono di ottenere il comportamento descritto sopra.
- Soluzioni progettuali per l'interoperatività tra le tecnologie scelte: realizzazione del plugin Nuxt per il collegamento con TypeORM e design patterns per la condivisione di strutture dati che rappresentano le entità del domain model tra il frontend ed il backend.
- Test di performance dell'applicazione in deploy su AWS.

Non ho ancora raffinato i dati per i test di performance, per i quali pensavo di fare dei grafici con i risultati ottenuti, e di fare un confronto tra le diverse topologie architetturali di server di calcolo e database. Tuttavia i risultati sono conformi a:
- AWS: ECS con carico moderato (100 richieste/sec) ha una latenza di 50-100ms, mentre con carico pesante(1000 richieste/sec) la latenza potrebbe triplicare. Lambda invece soffre di cold-start quindi ci sono circa 200-500ms di latenza per la prima richiesta ma la risposta a regime dovrebbe essere di circa 80-150ms con un database in cloud.
- Nuxt: Per app servite staticamente, un CSR potrebbe essere renderizzata in più di 1 secondo su dispositivi lenti, mentre una pagina SSG ha un tempo di caricamento senza overhead rispetto al bucket server. SSR su ECS con richieste API ha un tempo di risposta a partire dai 500ms. Quindi con UR si potrebbero unire i benefici di entrambi gli approcci, come mostrato nel capitolo 2.
- TypeORM: Le query che percorrono molti join con Active Record sono più lente di quelle con Query Builder, ma più facili da scrivere e mantenere. Query Builder ha a sua volta dei rallentamenti, ma trascurabili, rispetto a SQL raw. Per query semplici (1 join al massimo) active record, query builder e SQL raw si aggirano attorno ai 10ms con un database in locale. Tuttavia con query complesse, all'aumentare dei join, active record diventa più lento in ragione polinomiale (il così detto N+1 problem) invece query builder ha un costo circa lineare, ma maggiore di sql raw per via dell'esecuzione di funzioni aggiuntive.

Le chiedo se sia opportuno scegliere un tema per l'applicazione del branch di sviluppo che sto allestendo, magari anche in vista della presentazione, che si presti alla trattazione di API complesse con autenticazione e autorizzazione. Negli esempi che sto portando avanti il modello di dominio riguarda utenti, messaggi, post e commenti, quindi il tema per ora è un generico social network, ma potrei adattarlo con prontezza. Inoltre le chiedo se le sezioni del capitolo 3 ed i relativi test di performance siano adeguati.

Considerate le modifiche che Lei mi aveva suggerito durante l'ultima conferenza teams, e gli sviluppi proposti, le chiedo se il titolo: "Sviluppo ed analisi delle prestazioni di applicazioni web basate su Nuxt e TypeORM su servizi cloud AWS" è adeguato.

Grazie per l'attenzione, buona serata!
